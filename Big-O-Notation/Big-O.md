# Big-O 표기법

---

코드의 효율성을 계산할 때 직집적인 수치가 아닌 대략적인 추세를 갖고 표기하는 방식

## 구체적으로 하면 안 되는 이유?

우리는 몇 가지 코드의 효율성에 대해 직접 퍼포먼스를 계산해서 코드의 효율성을 구해볼 수 있다. 가령 이런식이다.

```
const addToN = (n) => {
  let result = 0
  for (let i = 0 ; i<n; i++) {
    result += i
  }

  return result
}

const t1 = performance.now()
addToN(100000000)
const t2 = performance.now()
console.log('시간측정 addToN',`${(t2-t1) / 1000} 초`)

const addToN_another = (n) => {
 return n *(n+1) / 2 // 공차가 1인 등차수열의 합 공식
}

const t3 = performance.now()
addToN_another(100000000)
const t4 = performance.now()
console.log('시간측정 addToN_another', `${(t3-t4) / 1000} 초` )


```

구체적인 수치를 콘솔창에서 확인 할 수 있을 것이다. 그러나 여기에는 문제가 있다. 파라미터의 값이 커질수록 연산의 속도는 느려지고 점점 그 수치를 확인하는데 너무 오랜 시간이 걸린다.

## Big-O로 표기한다면?

---

addToN은 O(n)
addToN_another O(1)

정확한 시간이 아닌 입력값에 대한 시간적인 수치를 바라보는 방식으로 표기한다면
하드웨어에 관계없이 어떤 알고리즘이 추세적으로 더 좋은지 판단할 수 있다.

## 공간 복잡도

---

지금까지는 알고리즘의 속도와 관련하여 빅오 표기법을 다루어 보았다.
그러나 빅오는 시간 복잡도뿐 아니라 알고리즘 자체가 필요로하는 공간에 대해서도 표기가 가능하다.
기본적으로 원시값(문자열 제외)은 O(1)의 공간 복잡도를 가지고
문자열 및 참조 타입은 O(n) 공간 복잡도를 가진다..

## 정리

---

코드의 효율성을 직접 측정하지 않아도 표기법을 통해서
대략적으로 파악할 수 있는 방법

정확한 숫자는 필요없다. 전체적인 추세를 보는 것이 빅오 표기법이다.

f(n) = n 입력값에 대한 출력시간
f(1) = 1 입력값에 대한 출력시간 복잡도는 상수다.
O(f(n)) = O(n) 이런식으로 표기 가능
O(f(1)) = O(1)

해당 표기법은 시간적 효율성 뿐만 아니라 메모리상 효율성을 따질 때도 사용할 수 있다.
